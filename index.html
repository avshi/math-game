<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Magic 3</title>

<style>
  body { font-family: Arial, sans-serif; background:#f4f4f4; margin:0; padding:0; }
  .wrap { max-width: 820px; margin: 0 auto; padding: 20px; }
  .card { background:white; border-radius: 14px; padding: 20px; box-shadow: 0 4px 18px rgba(0,0,0,.08); }

  .topbar{ display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; }
  h1 { margin: 0; }

  .rightTools { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

  .status {
    color:#0b1220;
    border-radius: 999px;
    padding:8px 12px;
    font-weight:800;
    font-size:14px;
    border: 1px solid rgba(0,0,0,.08);
    background: #e5e7eb;
  }

  .muteBtn{
    border: 1px solid rgba(0,0,0,.12);
    background: white;
    border-radius: 999px;
    padding:8px 12px;
    font-weight:800;
    cursor:pointer;
  }

  details.instructions {
    background:#eef4ff;
    padding:12px 14px;
    border-radius:12px;
    margin:12px 0 14px;
    font-size:15px;
    line-height:1.6;
  }
  details.instructions summary{
    cursor:pointer;
    font-weight:900;
    list-style: none;
    outline: none;
  }
  details.instructions summary::-webkit-details-marker { display:none; }
  .summaryRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .summaryHint{ font-weight:700; font-size:13px; opacity:.7; }

  .timer{
    background:#0b1220; color:white; padding:10px 12px; border-radius:12px;
    text-align:center; font-weight:bold; width: 180px; margin: 0 auto 14px; direction:ltr;
  }
  .timer.warn{ background:#8b0000; }

  .groups { display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin: 12px 0 14px; }
  .g { background:#fafafa; border:1px solid #eee; border-radius:12px; padding:12px; min-width:240px; text-align:center; }
  .nums { font-size:22px; direction:ltr; font-weight:800; }

  .row { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px; }
  input { font-size:18px; padding:10px 12px; width:230px; text-align:center; border-radius:10px; border:1px solid #ccc; }
  button { padding:10px 14px; font-size:15px; border-radius:10px; border:none; cursor:pointer; }
  .primary { background:#1a73e8; color:white; }
  .secondary { background:#eee; }
  .warnBtn { background:#ffefc7; }

  .msg { margin-top:15px; font-weight:bold; font-size:18px; }
  .ok { color:green; }
  .bad { color:red; }

  .proof {
    margin-top:10px;
    background:#0b1220;
    color:#e7eefc;
    padding:12px;
    border-radius:12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    direction:ltr;
    white-space: pre-wrap;
    text-align:left;
  }

  .panel {
    display:none;
    margin-top: 12px;
    background:#fff;
    border:1px solid #eee;
    border-radius:12px;
    padding:12px;
  }
  .panel h3 { margin: 0 0 8px; font-size: 16px; }
  .small { font-size: 14px; color:#444; line-height:1.4; }
</style>
</head>

<body>
<div class="wrap">
  <div class="card">

    <div class="topbar">
      <h1>ğŸ® Magic 3</h1>
      <div class="rightTools">
        <div class="status" id="levelStatus">Level: Super Easy â€¢ Streak: 0/2 â€¢ Time: 30s</div>
        <button class="muteBtn" id="muteBtn" onclick="toggleMute()">ğŸ”Š ×¡××•× ×“</button>
      </div>
    </div>

    <details class="instructions" id="howto" open>
      <summary>
        <div class="summaryRow">
          <span>××” ×¢×•×©×™×?</span>
          <span class="summaryHint" id="howtoHint">×”×¡×ª×¨ â–²</span>
        </div>
      </summary>
      <div style="margin-top:10px;">
        ×™×© 2 ×§×‘×•×¦×•×ª ×©×œ 3 ×¡×¤×¨×•×ª.<br>
        ×”××˜×¨×”: ×œ×‘×—×•×¨ <b>××¡×¤×¨ ×©×œ× ×—×™×•×‘×™</b> ×©××¤×©×¨ ×œ×”×’×™×¢ ××œ×™×• ×‘×©×ª×™ ×”×§×‘×•×¦×•×ª, ×ª×•×š ×©×™××•×© <b>×‘×›×œ ×”×¡×¤×¨×•×ª ×¤×¢× ××—×ª ×‘×œ×‘×“</b>.<br>
        ××•×ª×¨ ×ª××™×“ ×œ×”×©×ª××© ×‘Ö¾ <b>+ âˆ’ Ã— Ã·</b> ××‘×œ <b>××¡×•×¨ ×©×‘×¨×™×</b> (×’× ×‘×××¦×¢).<br><br>
        <b>×“×•×’××”:</b> ×§×‘×•×¦×” 1: [6,3,2] â†’ (6âˆ’3)Ã·2 = 1 &nbsp; | &nbsp; ×§×‘×•×¦×” 2: [9,4,5] â†’ (9âˆ’5)Ã·4 = 1
      </div>
    </details>

    <div class="timer" id="timerBox">Time: 30s</div>

    <div class="groups">
      <div class="g">
        <div><b>×§×‘×•×¦×” 1</b></div>
        <div class="nums" id="g1"></div>
      </div>
      <div class="g">
        <div><b>×§×‘×•×¦×” 2</b></div>
        <div class="nums" id="g2"></div>
      </div>
    </div>

    <div class="row">
      <input id="target" inputmode="numeric" placeholder="××¡×¤×¨ ×©×œ× ×—×™×•×‘×™ ×‘×œ×‘×“">
      <button class="primary" onclick="checkTarget()">×‘×“×•×§</button>
      <button class="secondary" onclick="newPuzzle()">×ª×¨×’×™×œ ×—×“×©</button>
      <button class="warnBtn" id="toggleBtn" onclick="toggleCommon()">×”×¦×’ ×ª×•×¦××•×ª ××©×•×ª×¤×•×ª</button>
    </div>

    <div class="msg" id="msg"></div>
    <div class="proof" id="proof" style="display:none;"></div>

    <div class="panel" id="commonPanel">
      <h3>×ª×•×¦××•×ª ××©×•×ª×¤×•×ª ××¤×©×¨×™×•×ª (××—×¨×™ ×¡×™× ×•×Ÿ ×”×¨××” ×•×”×–×™×›×¨×•×Ÿ)</h3>
      <div class="small" id="commonList"></div>
    </div>

  </div>
</div>

<script>
  // =======================
  //  Levels (DO NOT limit operations!)
  // =======================
  const LEVELS = [
    { name: "Super Easy", maxTarget: 9,  promoteWins: 2 },
    { name: "Easy",       maxTarget: 20, promoteWins: 3 },
    { name: "Medium",     maxTarget: 50, promoteWins: 3 },
    { name: "Hard",       maxTarget: 99, promoteWins: Infinity }
  ];

  // Badge colors per level
  const LEVEL_BADGE_BG = [
    "#dcfce7", // super easy - soft green
    "#dbeafe", // easy - soft blue
    "#fef3c7", // medium - soft amber
    "#fee2e2"  // hard - soft red
  ];

  let levelIndex = 0;
  let streak = 0;

  // time: +10 on each level up
  let baseTime = 30;

  function currentLevel(){ return LEVELS[levelIndex]; }

  function updateLevelStatus(){
    const lvl = currentLevel();
    const need = (lvl.promoteWins === Infinity) ? "âˆ" : String(lvl.promoteWins);
    const el = document.getElementById("levelStatus");
    el.textContent = `Level: ${lvl.name} â€¢ Streak: ${streak}/${need} â€¢ Time: ${baseTime}s`;
    el.style.background = LEVEL_BADGE_BG[levelIndex] || "#e5e7eb";
  }

  // =======================
  //  Mute
  // =======================
  let isMuted = false;

  function updateMuteBtn(){
    const btn = document.getElementById("muteBtn");
    btn.textContent = isMuted ? "ğŸ”‡ ×”×©×ª×§" : "ğŸ”Š ×¡××•× ×“";
  }

  function toggleMute(){
    isMuted = !isMuted;
    updateMuteBtn();
  }

  // =======================
  //  Collapsible hint text
  // =======================
  const howto = document.getElementById("howto");
  const howtoHint = document.getElementById("howtoHint");
  function syncHowtoHint(){
    howtoHint.textContent = howto.open ? "×”×¡×ª×¨ â–²" : "×”×¦×’ â–¼";
  }
  howto.addEventListener("toggle", syncHowtoHint);
  syncHowtoHint();

  // =======================
  //  Sounds (funny + countdown)
  // =======================
  function makeAudioCtx(){
    if (isMuted) return null;
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) return null;
    return new AudioCtx();
  }

  function playTone(ctx, freq, duration, wave="sine", gainVal=0.22){
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = wave;
    osc.frequency.value = freq;
    gain.gain.value = gainVal;
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    setTimeout(() => osc.stop(), duration);
  }

  function playFunnySound(type) {
    const ctx = makeAudioCtx();
    if (!ctx) return;

    if (type === "success") {
      playTone(ctx, 420, 90, "square");
      setTimeout(() => playTone(ctx, 720, 130, "square"), 90);
      setTimeout(() => playTone(ctx, 980, 180, "square"), 220);
    } else if (type === "fail") {
      playTone(ctx, 520, 160, "sawtooth");
      setTimeout(() => playTone(ctx, 320, 240, "sawtooth"), 160);
    } else if (type === "timeout") {
      playTone(ctx, 650, 180, "triangle");
      setTimeout(() => playTone(ctx, 430, 200, "triangle"), 180);
      setTimeout(() => playTone(ctx, 220, 260, "triangle"), 380);
    } else if (type === "levelup") {
      playTone(ctx, 600, 90, "square");
      setTimeout(() => playTone(ctx, 800, 120, "square"), 90);
      setTimeout(() => playTone(ctx, 1100, 160, "square"), 210);
    }

    setTimeout(() => ctx.close(), 900);
  }

  function playCountdownBeep(secondsLeft){
    const ctx = makeAudioCtx();
    if (!ctx) return;
    const pitch = 520 + (8 - secondsLeft) * 80; // 8->520, 1->1080
    const wave = (secondsLeft <= 2) ? "square" : "sine";
    playTone(ctx, pitch, 90, wave, 0.18);
    setTimeout(() => ctx.close(), 200);
  }

  // =======================
  //  Timer
  // =======================
  let timeLeft = baseTime;
  let timerId = null;
  let roundActive = true;

  function startTimer(){
    stopTimer();
    timeLeft = baseTime;
    roundActive = true;
    updateTimer();
    timerId = setInterval(()=>{
      timeLeft--;
      updateTimer();

      if (roundActive && timeLeft <= 8 && timeLeft >= 1){
        playCountdownBeep(timeLeft);
      }

      if(timeLeft <= 0){
        timeLeft = 0;
        updateTimer();
        stopTimer();
        roundActive = false;
        streak = 0;
        updateLevelStatus();
        setMessage("â° × ×’××¨ ×”×–××Ÿ! ×œ×—×¥ '×ª×¨×’×™×œ ×—×“×©' ×›×“×™ ×œ× ×¡×•×ª ×©×•×‘.", false);
        document.getElementById("proof").style.display = "none";
        playFunnySound("timeout");
      }
    }, 1000);
  }

  function stopTimer(){
    if(timerId){
      clearInterval(timerId);
      timerId = null;
    }
  }

  function updateTimer(){
    const box = document.getElementById("timerBox");
    box.textContent = `Time: ${timeLeft}s`;
    box.classList.toggle("warn", timeLeft <= 8 && roundActive);
  }

  // =======================
  //  Exact integer-only math
  //  (Always integers, including intermediates)
  // =======================
  function frac(n,d){
    if(d === 0) return null;
    if(d < 0){ n = -n; d = -d; }
    // we only care about integer-ness -> keep reduced-ish
    const g = gcd(Math.abs(n), Math.abs(d));
    return { n: n/g, d: d/g };
  }
  function gcd(a,b){ while(b){ [a,b] = [b, a % b]; } return a || 1; }

  function add(a,b){ return frac(a.n*b.d + b.n*a.d, a.d*b.d); }
  function sub(a,b){ return frac(a.n*b.d - b.n*a.d, a.d*b.d); }
  function mul(a,b){ return frac(a.n*b.n, a.d*b.d); }
  function div(a,b){ if(b.n === 0) return null; return frac(a.n*b.d, a.d*b.n); }

  function isInt(f){ return f && f.d === 1; }

  function perms3(a){
    return [
      [a[0],a[1],a[2]],[a[0],a[2],a[1]],
      [a[1],a[0],a[2]],[a[1],a[2],a[0]],
      [a[2],a[0],a[1]],[a[2],a[1],a[0]]
    ];
  }

  const OP_FUNCS = { "+": add, "-": sub, "*": mul, "/": div };

  // Build results using allowed ops, ALWAYS requiring integer intermediates and integer final
  function getIntegerResultsWithProof(nums, allowedOps, maxTarget){
    const out = new Map();

    for(const [x,y,z] of perms3(nums)){
      const fx = frac(x,1), fy = frac(y,1), fz = frac(z,1);

      for(const op1 of allowedOps){
        for(const op2 of allowedOps){
          const f1 = OP_FUNCS[op1];
          const f2 = OP_FUNCS[op2];

          // (x op1 y) op2 z
          const r1 = f1(fx, fy);
          if(isInt(r1)){
            const r = f2(r1, fz);
            if(isInt(r) && r.n > 0 && r.n <= maxTarget && !out.has(r.n)){
              out.set(r.n, `(${x} ${op1} ${y}) ${op2} ${z}`);
            }
          }

          // x op1 (y op2 z)
          const r2 = f2(fy, fz);
          if(isInt(r2)){
            const r = f1(fx, r2);
            if(isInt(r) && r.n > 0 && r.n <= maxTarget && !out.has(r.n)){
              out.set(r.n, `${x} ${op1} (${y} ${op2} ${z})`);
            }
          }
        }
      }
    }

    return out;
  }

  function randDigit(){ return Math.floor(Math.random()*9)+1; }

  // Always allowed for user:
  const ALL_OPS = ["+","-","*","/"];
  const PLUS_MINUS_OPS = ["+","-"];

  let group1 = [0,0,0];
  let group2 = [0,0,0];
  let map1 = new Map(); // all ops (integer-only), for checking correctness
  let map2 = new Map();

  // Remember last 3 solved targets (newest first)
  let lastSolvedHistory = [];

  function setMessage(text, ok){
    const el = document.getElementById("msg");
    el.textContent = text;
    el.className = "msg " + (ok ? "ok" : "bad");
  }

  function updateCommonPanel(list){
    const el = document.getElementById("commonList");
    el.textContent = list.length ? list.join(", ") : "××™×Ÿ ×ª×•×¦××•×ª ××¤×©×¨×™×•×ª (××—×¨×™ ×”×¡×™× ×•×Ÿ).";
  }

  function newPuzzle(){
    updateLevelStatus();

    // Randomly avoid 2 or 3 last solved targets:
    // STRONG rule: next puzzle must NOT have these as common results at all.
    const avoidCount = (Math.random() < 0.5) ? 2 : 3;
    const avoidSet = new Set(lastSolvedHistory.slice(0, avoidCount));

    const lvl = currentLevel();
    let tries = 0;

    while(true){
      group1 = [randDigit(), randDigit(), randDigit()];
      group2 = [randDigit(), randDigit(), randDigit()];

      // All-ops results (integer-only always)
      map1 = getIntegerResultsWithProof(group1, ALL_OPS, lvl.maxTarget);
      map2 = getIntegerResultsWithProof(group2, ALL_OPS, lvl.maxTarget);

      // Common results (all ops)
      const commonAll = [...map1.keys()].filter(k => map2.has(k));

      // must have at least one common
      if(commonAll.length === 0){
        tries++; if(tries > 4000) break; continue;
      }

      // strong avoid: none of avoided targets may appear in common
      if(avoidSet.size > 0 && commonAll.some(x => avoidSet.has(x))){
        tries++; if(tries > 4000) break; continue;
      }

      // Super Easy rule: ensure there exists at least one common solution using ONLY +/-
      if(levelIndex === 0){
        const pm1 = getIntegerResultsWithProof(group1, PLUS_MINUS_OPS, lvl.maxTarget);
        const pm2 = getIntegerResultsWithProof(group2, PLUS_MINUS_OPS, lvl.maxTarget);
        const commonPM = [...pm1.keys()].filter(k => pm2.has(k));

        // must have at least one +/âˆ’ only common result
        if(commonPM.length === 0){
          tries++; if(tries > 4000) break; continue;
        }

        // also strong avoid applies (avoid targets cannot be common even in +/âˆ’ set; it's implied by all-ops check,
        // but keep it tight in case of future changes)
        if(avoidSet.size > 0 && commonPM.some(x => avoidSet.has(x))){
          tries++; if(tries > 4000) break; continue;
        }
      }

      // For panel (debug/help): show the common results the user could choose from (all ops)
      const list = commonAll.slice().sort((a,b)=>a-b);
      updateCommonPanel(list);
      break;
    }

    document.getElementById("g1").textContent = `[${group1.join(", ")}]`;
    document.getElementById("g2").textContent = `[${group2.join(", ")}]`;

    document.getElementById("target").value = "";
    document.getElementById("proof").style.display = "none";
    document.getElementById("proof").textContent = "";
    document.getElementById("msg").textContent = "";

    document.getElementById("commonPanel").style.display = "none";
    document.getElementById("toggleBtn").textContent = "×”×¦×’ ×ª×•×¦××•×ª ××©×•×ª×¤×•×ª";

    startTimer();
    document.getElementById("target").focus();
  }

  function tryLevelUp(){
    const lvl = currentLevel();
    if(lvl.promoteWins === Infinity) return;

    if(streak >= lvl.promoteWins){
      levelIndex = Math.min(levelIndex + 1, LEVELS.length - 1);
      streak = 0;
      baseTime += 10;
      playFunnySound("levelup");
      updateLevelStatus();
    }
  }

  function checkTarget(){
    if(!roundActive){
      setMessage("×”×¡×™×‘×•×‘ × ×’××¨. ×œ×—×¥ '×ª×¨×’×™×œ ×—×“×©' ×›×“×™ ×œ×”×ª×—×™×œ ×©×•×‘.", false);
      return;
    }

    const s = (document.getElementById("target").value || "").trim();
    const v = Number(s);
    if(!Number.isFinite(v) || !Number.isInteger(v) || v <= 0){
      setMessage("×”×›× ×¡ ××¡×¤×¨ ×©×œ× ×—×™×•×‘×™ ×‘×œ×‘×“ (×œ××©×œ 5).", false);
      playFunnySound("fail");
      document.getElementById("proof").style.display = "none";
      streak = 0;
      updateLevelStatus();
      return;
    }

    const t = v;

    if(map1.has(t) && map2.has(t)){
      setMessage("âœ… × ×›×•×Ÿ! ××¦××ª ×ª×•×¦××” ××©×•×ª×¤×ª.", true);
      playFunnySound("success");

      const proof = document.getElementById("proof");
      proof.style.display = "block";
      proof.textContent =
        `Group 1: ${map1.get(t)} = ${t}\n` +
        `Group 2: ${map2.get(t)} = ${t}`;

      lastSolvedHistory.unshift(t);
      lastSolvedHistory = lastSolvedHistory.slice(0, 3);

      streak++;
      tryLevelUp();
      updateLevelStatus();

      roundActive = false;
      stopTimer();
      updateTimer();
    } else {
      setMessage("âŒ ×œ× × ×›×•×Ÿ. ×”×ª×•×¦××” ×”×–×• ×œ× ××¤×©×¨×™×ª ×‘×©×ª×™ ×”×§×‘×•×¦×•×ª (×‘×œ×™ ×©×‘×¨×™×) ×œ×¤×™ ×”×¨××”.", false);
      playFunnySound("fail");
      document.getElementById("proof").style.display = "none";
      streak = 0;
      updateLevelStatus();
    }
  }

  function toggleCommon(){
    const panel = document.getElementById("commonPanel");
    const btn = document.getElementById("toggleBtn");
    const isOpen = panel.style.display === "block";
    panel.style.display = isOpen ? "none" : "block";
    btn.textContent = isOpen ? "×”×¦×’ ×ª×•×¦××•×ª ××©×•×ª×¤×•×ª" : "×”×¡×ª×¨ ×ª×•×¦××•×ª ××©×•×ª×¤×•×ª";
  }

  document.addEventListener("keydown", (e) => {
    if (e.key === "Enter") checkTarget();
  });

  // start
  updateMuteBtn();
  updateLevelStatus();
  newPuzzle();
</script>
</body>
</html>
